<!-- build time:Sun May 03 2020 21:06:59 GMT+0800 (China Standard Time) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 4.2.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon_32.ico"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon_16.ico"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:new URL("https://www.guitu18.com").hostname,root:"/",scheme:"Gemini",version:"7.6.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:"mac"},back2top:{enable:!0,sidebar:!1,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!0,mediumzoom:!1,lazyload:!1,pangu:!0,comments:{style:"tabs",active:"valine",storage:!0,lazyload:!1,nav:null},algolia:{appID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!1,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},path:"",motion:{enable:!0,async:!0,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}}}</script><meta name="keywords" content="夜月归途,个人博客,guitu18,原创Java技术分享"><meta name="description" content="在开始之前关于本教程新的输入&#x2F;输出 (NIO) 库是在 JDK 1.4 中引入的。NIO 弥补了原来的 I&#x2F;O 的不足，它在标准 Java 代码中提供了高速的、面向块的 I&#x2F;O。通过定义包含数据的类，以及通过以块的形式处理这些数据，NIO 不用使用本机代码就可以利用低级优化，这是原来的 I&#x2F;O 包所无法做到的。在本教程中，我们将讨论 NIO 库的几乎所有方面，从高级的概念性内容到底层的编程细节。除"><meta property="og:type" content="article"><meta property="og:title" content="NIO 入门"><meta property="og:url" content="https://www.guitu18.com/post/2019/05/18/34.html"><meta property="og:site_name" content="夜月归途"><meta property="og:description" content="在开始之前关于本教程新的输入&#x2F;输出 (NIO) 库是在 JDK 1.4 中引入的。NIO 弥补了原来的 I&#x2F;O 的不足，它在标准 Java 代码中提供了高速的、面向块的 I&#x2F;O。通过定义包含数据的类，以及通过以块的形式处理这些数据，NIO 不用使用本机代码就可以利用低级优化，这是原来的 I&#x2F;O 包所无法做到的。在本教程中，我们将讨论 NIO 库的几乎所有方面，从高级的概念性内容到底层的编程细节。除"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://img.guitu18.com/markdown/974dfb67bb638b7e589e0503e61be06f.gif"><meta property="og:image" content="https://img.guitu18.com/markdown/9ca400795816cd8148a415dd291bb55f.gif"><meta property="og:image" content="https://img.guitu18.com/markdown/5f855b264d50d852e555393fbd5588cc.gif"><meta property="og:image" content="https://img.guitu18.com/markdown/e88a24821db310464d8a08992568ef37.gif"><meta property="og:image" content="https://img.guitu18.com/markdown/ef3aaadc4fa8aae9a47ace7811408260.gif"><meta property="og:image" content="https://img.guitu18.com/markdown/f416bdb984e2f1f2c299f9a18088ffbf.gif"><meta property="og:image" content="https://img.guitu18.com/markdown/e435d53b79b7d5056659266449b94ac2.gif"><meta property="og:image" content="https://img.guitu18.com/markdown/3453374e843eac43b526d06b12f8b741.gif"><meta property="og:image" content="https://img.guitu18.com/markdown/25b36164d49a2ec4d1d4ff4dd52fa7ea.gif"><meta property="article:published_time" content="2019-05-18T09:22:57.000Z"><meta property="article:modified_time" content="2019-05-18T09:22:57.000Z"><meta property="article:author" content="Guitu"><meta property="article:tag" content="NIO"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://img.guitu18.com/markdown/974dfb67bb638b7e589e0503e61be06f.gif"><link rel="canonical" href="https://www.guitu18.com/post/2019/05/18/34.html"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0}</script><title>NIO 入门 | 夜月归途</title><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?827f811db6b41b489d3e11e73a29f977";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-meta"><div><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">夜月归途</span> <span class="logo-line-after"><i></i></span></a></div><h1 class="site-subtitle" itemprop="description">一个安静的小角落</h1></div><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a></li><li class="menu-item menu-item-链接"><a href="/links/" rel="section"><i class="fa fa-fw fa-sitemap"></i>链接</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a></li></ul></nav></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><div class="reading-progress-bar"></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content"><div class="posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.guitu18.com/post/2019/05/18/34.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Guitu"><meta itemprop="description" content="用实力让情怀落地"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="夜月归途"></span><header class="post-header"><h2 class="post-title" itemprop="name headline">NIO 入门</h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-05-18 17:22:57" itemprop="dateCreated datePublished" datetime="2019-05-18T17:22:57+08:00">2019-05-18</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">学习</span> </a></span>， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E5%AD%A6%E4%B9%A0/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span> </a></span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span id="busuanzi_value_page_pv"></span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><span class="post-meta-item-text">Valine：</span> <a title="valine" href="/post/2019/05/18/34.html#comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/post/2019/05/18/34.html" itemprop="commentCount"></span></a></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>20k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>18 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="在开始之前"><a href="#在开始之前" class="headerlink" title="在开始之前"></a>在开始之前</h2><h3 id="关于本教程"><a href="#关于本教程" class="headerlink" title="关于本教程"></a>关于本教程</h3><p>新的输入/输出 (NIO) 库是在 JDK 1.4 中引入的。NIO 弥补了原来的 I/O 的不足，它在标准 Java 代码中提供了高速的、面向块的 I/O。通过定义包含数据的类，以及通过以块的形式处理这些数据，NIO 不用使用本机代码就可以利用低级优化，这是原来的 I/O 包所无法做到的。</p><p>在本教程中，我们将讨论 NIO 库的几乎所有方面，从高级的概念性内容到底层的编程细节。除了学习诸如缓冲区和通道这样的关键 I/O 元素外，您还有机会看到在更新后的库中标准 I/O 是如何工作的。您还会了解只能通过 NIO 来完成的工作，如异步 I/O 和直接缓冲区。</p><p>在本教程中，我们将使用展示 NIO 库的不同方面的代码示例。几乎每一个代码示例都是一个大的 Java 程序的一部分，您可以在 <a href="https://www.ibm.com/developerworks/cn/education/java/j-nio/j-nio.html#ma" target="_blank" rel="noopener">参考资料</a> 中找到这个 Java 程序。在做这些练习时，我们推荐您在自己的系统上下载、编译和运行这些程序。在您学习了本教程以后，这些代码将为您的 NIO 编程努力提供一个起点。</p><p>本教程是为希望学习更多关于 JDK 1.4 NIO 库的知识的所有程序员而写的。为了最大程度地从这里的讨论中获益，您应该理解基本的 Java 编程概念，如类、继承和使用包。多少熟悉一些原来的 I/O 库(来自 <code>java.io.*</code> 包)也会有所帮助。</p><p>虽然本教程要求掌握 Java 语言的工作词汇和概念，但是不需要有很多实际编程经验。除了彻底介绍与本教程有关的所有概念外，我还保持代码示例尽可能短小和简单。目的是让即使没有多少 Java 编程经验的读者也能容易地开始学习 NIO。</p><h3 id="如何运行代码"><a href="#如何运行代码" class="headerlink" title="如何运行代码"></a>如何运行代码</h3><p>源代码归档文件(在 <a href="https://www.ibm.com/developerworks/cn/education/java/j-nio/j-nio.html#ma" target="_blank" rel="noopener">参考资料</a> 中提供)包含了本教程中使用的所有程序。每一个程序都由一个 Java 文件构成。每一个文件都根据名称来识别，并且可以容易地与它所展示的编程概念相关联。</p><p>教程中的一些程序需要命令行参数才能运行。要从命令行运行一个程序，只需使用最方便的命令行提示符。在 Windows 中，命令行提供符是 “Command” 或者 “command.com” 程序。在 UNIX 中，可以使用任何 shell。</p><p>需要安装 JDK 1.4 并将它包括在路径中，才能完成本教程中的练习。如果需要安装和配置 JDK 1.4 的帮助，请参见 <a href="https://www.ibm.com/developerworks/cn/education/java/j-nio/j-nio.html#ma" target="_blank" rel="noopener">参考资料</a>。</p><h2 id="输入-输出：概念性描述"><a href="#输入-输出：概念性描述" class="headerlink" title="输入/输出：概念性描述"></a>输入/输出：概念性描述</h2><h3 id="I-O-简介"><a href="#I-O-简介" class="headerlink" title="I/O 简介"></a>I/O 简介</h3><p>I/O ? 或者输入/输出 ? 指的是计算机与外部世界或者一个程序与计算机的其余部分的之间的接口。它对于任何计算机系统都非常关键，因而所有 I/O 的主体实际上是内置在操作系统中的。单独的程序一般是让系统为它们完成大部分的工作。</p><p>在 Java 编程中，直到最近一直使用 <em>流</em> 的方式完成 I/O。所有 I/O 都被视为单个的字节的移动，通过一个称为 Stream 的对象一次移动一个字节。流 I/O 用于与外部世界接触。它也在内部使用，用于将对象转换为字节，然后再转换回对象。</p><p>NIO 与原来的 I/O 有同样的作用和目的，但是它使用不同的方式? <em>块 I/O</em>。正如您将在本教程中学到的，块 I/O 的效率可以比流 I/O 高许多。</p><h3 id="为什么要使用-NIO"><a href="#为什么要使用-NIO" class="headerlink" title="为什么要使用 NIO?"></a>为什么要使用 NIO?</h3><p>NIO 的创建目的是为了让 Java 程序员可以实现高速 I/O 而无需编写自定义的本机代码。NIO 将最耗时的 I/O 操作(即填充和提取缓冲区)转移回操作系统，因而可以极大地提高速度。</p><h3 id="流与块的比较"><a href="#流与块的比较" class="headerlink" title="流与块的比较"></a>流与块的比较</h3><p>原来的 I/O 库(在 <code>java.io.*</code>中) 与 NIO 最重要的区别是数据打包和传输的方式。正如前面提到的，原来的 I/O 以流的方式处理数据，而 NIO 以块的方式处理数据。</p><p><em>面向流</em> 的 I/O 系统一次一个字节地处理数据。一个输入流产生一个字节的数据，一个输出流消费一个字节的数据。为流式数据创建过滤器非常容易。链接几个过滤器，以便每个过滤器只负责单个复杂处理机制的一部分，这样也是相对简单的。不利的一面是，面向流的 I/O 通常相当慢。</p><p>一个 <em>面向块</em> 的 I/O 系统以块的形式处理数据。每一个操作都在一步中产生或者消费一个数据块。按块处理数据比按(流式的)字节处理数据要快得多。但是面向块的 I/O 缺少一些面向流的 I/O 所具有的优雅性和简单性。</p><h3 id="集成的-I-O"><a href="#集成的-I-O" class="headerlink" title="集成的 I/O"></a>集成的 I/O</h3><p>在 JDK 1.4 中原来的 I/O 包和 NIO 已经很好地集成了。 <code>java.io.*</code> 已经以 NIO 为基础重新实现了，所以现在它可以利用 NIO 的一些特性。例如， <code>java.io.*</code> 包中的一些类包含以块的形式读写数据的方法，这使得即使在更面向流的系统中，处理速度也会更快。</p><p>也可以用 NIO 库实现标准 I/O 功能。例如，可以容易地使用块 I/O 一次一个字节地移动数据。但是正如您会看到的，NIO 还提供了原 I/O 包中所没有的许多好处。</p><h2 id="通道和缓冲区"><a href="#通道和缓冲区" class="headerlink" title="通道和缓冲区"></a>通道和缓冲区</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><code>通道</code>和 <code>缓冲区</code>是 NIO 中的核心对象，几乎在每一个 I/O 操作中都要使用它们。</p><p>通道是对原 I/O 包中的流的模拟。到任何目的地(或来自任何地方)的所有数据都必须通过一个 Channel 对象。一个 Buffer 实质上是一个容器对象。发送给一个通道的所有对象都必须首先放到缓冲区中；同样地，从通道中读取的任何数据都要读到缓冲区中。</p><p>在本节中，您会了解到 NIO 中通道和缓冲区是如何工作的。</p><h3 id="什么是缓冲区？"><a href="#什么是缓冲区？" class="headerlink" title="什么是缓冲区？"></a>什么是缓冲区？</h3><p><code>Buffer</code> 是一个对象， 它包含一些要写入或者刚读出的数据。 在 NIO 中加入 <code>Buffer</code> 对象，体现了新库与原 I/O 的一个重要区别。在面向流的 I/O 中，您将数据直接写入或者将数据直接读到 <code>Stream</code> 对象中。</p><p>在 NIO 库中，所有数据都是用缓冲区处理的。在读取数据时，它是直接读到缓冲区中的。在写入数据时，它是写入到缓冲区中的。任何时候访问 NIO 中的数据，您都是将它放到缓冲区中。</p><p>缓冲区实质上是一个数组。通常它是一个字节数组，但是也可以使用其他种类的数组。但是一个缓冲区不 <em>仅仅</em> 是一个数组。缓冲区提供了对数据的结构化访问，而且还可以跟踪系统的读/写进程。</p><h3 id="缓冲区类型"><a href="#缓冲区类型" class="headerlink" title="缓冲区类型"></a>缓冲区类型</h3><p>最常用的缓冲区类型是 <code>ByteBuffer</code>。一个 <code>ByteBuffer</code> 可以在其底层字节数组上进行 get/set 操作(即字节的获取和设置)。</p><p><code>ByteBuffer</code> 不是 NIO 中唯一的缓冲区类型。事实上，对于每一种基本 Java 类型都有一种缓冲区类型：</p><ul><li><code>ByteBuffer</code></li><li><code>CharBuffer</code></li><li><code>ShortBuffer</code></li><li><code>IntBuffer</code></li><li><code>LongBuffer</code></li><li><code>FloatBuffer</code></li><li><code>DoubleBuffer</code></li></ul><p>每一个 <code>Buffer</code> 类都是 <code>Buffer</code> 接口的一个实例。 除了 <code>ByteBuffer</code>，每一个 Buffer 类都有完全一样的操作，只是它们所处理的数据类型不一样。因为大多数标准 I/O 操作都使用 <code>ByteBuffer</code>，所以它具有所有共享的缓冲区操作以及一些特有的操作。</p><p>现在您可以花一点时间运行 UseFloatBuffer.java，它包含了类型化的缓冲区的一个应用例子。</p><h3 id="什么是通道？"><a href="#什么是通道？" class="headerlink" title="什么是通道？"></a>什么是通道？</h3><p><code>Channel</code>是一个对象，可以通过它读取和写入数据。拿 NIO 与原来的 I/O 做个比较，通道就像是流。</p><p>正如前面提到的，所有数据都通过 <code>Buffer</code> 对象来处理。您永远不会将字节直接写入通道中，相反，您是将数据写入包含一个或者多个字节的缓冲区。同样，您不会直接从通道中读取字节，而是将数据从通道读入缓冲区，再从缓冲区获取这个字节。</p><h3 id="通道类型"><a href="#通道类型" class="headerlink" title="通道类型"></a>通道类型</h3><p>通道与流的不同之处在于通道是双向的。而流只是在一个方向上移动(一个流必须是 <code>InputStream</code> 或者 <code>OutputStream</code> 的子类)， 而 <code>通道</code>可以用于读、写或者同时用于读写。</p><p>因为它们是双向的，所以通道可以比流更好地反映底层操作系统的真实情况。特别是在 UNIX 模型中，底层操作系统通道是双向的。</p><h2 id="从理论到实践：NIO-中的读和写"><a href="#从理论到实践：NIO-中的读和写" class="headerlink" title="从理论到实践：NIO 中的读和写"></a>从理论到实践：NIO 中的读和写</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>读和写是 I/O 的基本过程。从一个通道中读取很简单：只需创建一个缓冲区，然后让通道将数据读到这个缓冲区中。写入也相当简单：创建一个缓冲区，用数据填充它，然后让通道用这些数据来执行写入操作。</p><p>在本节中，我们将学习有关在 Java 程序中读取和写入数据的一些知识。我们将回顾 NIO 的主要组件(缓冲区、通道和一些相关的方法)，看看它们是如何交互以进行读写的。在接下来的几节中，我们将更详细地分析这其中的每个组件以及其交互。</p><h3 id="从文件中读取"><a href="#从文件中读取" class="headerlink" title="从文件中读取"></a>从文件中读取</h3><p>在我们第一个练习中，我们将从一个文件中读取一些数据。如果使用原来的 I/O，那么我们只需创建一个 <code>FileInputStream</code> 并从它那里读取。而在 NIO 中，情况稍有不同：我们首先从 <code>FileInputStream</code> 获取一个 <code>Channel</code> 对象，然后使用这个通道来读取数据。</p><p>在 NIO 系统中，任何时候执行一个读操作，您都是从通道中读取，但是您不是 <em>直接</em> 从通道读取。因为所有数据最终都驻留在缓冲区中，所以您是从通道读到缓冲区中。</p><p>因此读取文件涉及三个步骤：(1) 从 <code>FileInputStream</code> 获取 <code>Channel</code>，(2) 创建 <code>Buffer</code>，(3) 将数据从 <code>Channel</code> 读到 <code>Buffer</code>中。</p><p>现在，让我们看一下这个过程。</p><h3 id="三个容易的步骤"><a href="#三个容易的步骤" class="headerlink" title="三个容易的步骤"></a>三个容易的步骤</h3><p>第一步是获取通道。我们从 <code>FileInputStream</code> 获取通道：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream fin = <span class="keyword">new</span> FileInputStream( <span class="string">"readandshow.txt"</span> );</span><br><span class="line">FileChannel fc = fin.getChannel();</span><br></pre></td></tr></table></figure><p>下一步是创建缓冲区：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buffer = ByteBuffer.allocate( <span class="number">1024</span> );</span><br></pre></td></tr></table></figure><p>最后，需要将数据从通道读到缓冲区中，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fc.read( buffer );</span><br></pre></td></tr></table></figure><p>您会注意到，我们不需要告诉通道要读 <em>多少数据</em> 到缓冲区中。每一个缓冲区都有复杂的内部统计机制，它会跟踪已经读了多少数据以及还有多少空间可以容纳更多的数据。我们将在 <a href="https://www.ibm.com/developerworks/cn/education/java/j-nio/j-nio.html#" target="_blank" rel="noopener">缓冲区内部细节</a> 中介绍更多关于缓冲区统计机制的内容。</p><h3 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h3><p>在 NIO 中写入文件类似于从文件中读取。首先从 <code>FileOutputStream</code> 获取一个通道：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FileOutputStream fout = <span class="keyword">new</span> FileOutputStream( <span class="string">"writesomebytes.txt"</span> );</span><br><span class="line">FileChannel fc = fout.getChannel();</span><br></pre></td></tr></table></figure><p>下一步是创建一个缓冲区并在其中放入一些数据 - 在这里，数据将从一个名为 <code>message</code> 的数组中取出，这个数组包含字符串 “Some bytes” 的 ASCII 字节(本教程后面将会解释 <code>buffer.flip()</code> 和 <code>buffer.put()</code> 调用)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buffer = ByteBuffer.allocate( <span class="number">1024</span> );</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;message.length; ++i) &#123;</span><br><span class="line">     buffer.put( message[i] );</span><br><span class="line">&#125;</span><br><span class="line">buffer.flip();</span><br></pre></td></tr></table></figure><p>最后一步是写入缓冲区中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fc.write( buffer );</span><br></pre></td></tr></table></figure><p>注意在这里同样不需要告诉通道要写入多数据。缓冲区的内部统计机制会跟踪它包含多少数据以及还有多少数据要写入。</p><h3 id="读写结合"><a href="#读写结合" class="headerlink" title="读写结合"></a>读写结合</h3><p>下面我们将看一下在结合读和写时会有什么情况。我们以一个名为 CopyFile.java 的简单程序作为这个练习的基础，它将一个文件的所有内容拷贝到另一个文件中。CopyFile.java 执行三个基本操作：首先创建一个 <code>Buffer</code>，然后从源文件中将数据读到这个缓冲区中，然后将缓冲区写入目标文件。这个程序不断重复 ― 读、写、读、写 ― 直到源文件结束。</p><p>CopyFile 程序让您看到我们如何检查操作的状态，以及如何使用 <code>clear()</code> 和 <code>flip()</code> 方法重设缓冲区，并准备缓冲区以便将新读取的数据写到另一个通道中。</p><h3 id="运行-CopyFile-例子"><a href="#运行-CopyFile-例子" class="headerlink" title="运行 CopyFile 例子"></a>运行 CopyFile 例子</h3><p>因为缓冲区会跟踪它自己的数据，所以 CopyFile 程序的内部循环 (inner loop) 非常简单，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fcin.read( buffer );``fcout.write( buffer );</span><br></pre></td></tr></table></figure><p>第一行将数据从输入通道 <code>fcin</code> 中读入缓冲区，第二行将这些数据写到输出通道 <code>fcout</code> 。</p><h3 id="检查状态"><a href="#检查状态" class="headerlink" title="检查状态"></a>检查状态</h3><p>下一步是检查拷贝何时完成。当没有更多的数据时，拷贝就算完成，并且可以在 <code>read()</code> 方法返回 -1 是判断这一点，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> r = fcin.read( buffer );</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (r==-<span class="number">1</span>) &#123;</span><br><span class="line">     <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重设缓冲区"><a href="#重设缓冲区" class="headerlink" title="重设缓冲区"></a>重设缓冲区</h3><p>最后，在从输入通道读入缓冲区之前，我们调用 <code>clear()</code> 方法。同样，在将缓冲区写入输出通道之前，我们调用 <code>flip()</code> 方法，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">buffer.clear();</span><br><span class="line"><span class="keyword">int</span> r = fcin.read( buffer );</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (r==-<span class="number">1</span>) &#123;</span><br><span class="line">     <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">buffer.flip();</span><br><span class="line">fcout.write( buffer );</span><br></pre></td></tr></table></figure><p><code>clear()</code> 方法重设缓冲区，使它可以接受读入的数据。 <code>flip()</code> 方法让缓冲区可以将新读入的数据写入另一个通道。</p><h2 id="缓冲区内部细节"><a href="#缓冲区内部细节" class="headerlink" title="缓冲区内部细节"></a>缓冲区内部细节</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p>本节将介绍 NIO 中两个重要的缓冲区组件：状态变量和访问方法 (accessor)。</p><p>状态变量是前一节中提到的”内部统计机制”的关键。每一个读/写操作都会改变缓冲区的状态。通过记录和跟踪这些变化，缓冲区就可能够内部地管理自己的资源。</p><p>在从通道读取数据时，数据被放入到缓冲区。在有些情况下，可以将这个缓冲区直接写入另一个通道，但是在一般情况下，您还需要查看数据。这是使用 <em>访问方法</em> <code>get()</code> 来完成的。同样，如果要将原始数据放入缓冲区中，就要使用访问方法 <code>put()</code>。</p><p>在本节中，您将学习关于 NIO 中的状态变量和访问方法的内容。我们将描述每一个组件，并让您有机会看到它的实际应用。虽然 NIO 的内部统计机制初看起来可能很复杂，但是您很快就会看到大部分的实际工作都已经替您完成了。您可能习惯于通过手工编码进行簿记 ― 即使用字节数组和索引变量，现在它已在 NIO 中内部地处理了。</p><h3 id="状态变量"><a href="#状态变量" class="headerlink" title="状态变量"></a>状态变量</h3><p>可以用三个值指定缓冲区在任意时刻的状态：</p><ul><li><code>position</code></li><li><code>limit</code></li><li><code>capacity</code></li></ul><p>这三个变量一起可以跟踪缓冲区的状态和它所包含的数据。我们将在下面的小节中详细分析每一个变量，还要介绍它们如何适应典型的读/写(输入/输出)进程。在这个例子中，我们假定要将数据从一个输入通道拷贝到一个输出通道。</p><h3 id="Position"><a href="#Position" class="headerlink" title="Position"></a>Position</h3><p>您可以回想一下，缓冲区实际上就是美化了的数组。在从通道读取时，您将所读取的数据放到底层的数组中。 <code>position</code> 变量跟踪已经写了多少数据。更准确地说，它指定了下一个字节将放到数组的哪一个元素中。因此，如果您从通道中读三个字节到缓冲区中，那么缓冲区的 <code>position</code> 将会设置为3，指向数组中第四个元素。</p><p>同样，在写入通道时，您是从缓冲区中获取数据。 <code>position</code> 值跟踪从缓冲区中获取了多少数据。更准确地说，它指定下一个字节来自数组的哪一个元素。因此如果从缓冲区写了5个字节到通道中，那么缓冲区的 <code>position</code> 将被设置为5，指向数组的第六个元素。</p><h3 id="Limit"><a href="#Limit" class="headerlink" title="Limit"></a>Limit</h3><p><code>limit</code> 变量表明还有多少数据需要取出(在从缓冲区写入通道时)，或者还有多少空间可以放入数据(在从通道读入缓冲区时)。</p><p><code>position</code> 总是小于或者等于 <code>limit</code>。</p><h3 id="Capacity"><a href="#Capacity" class="headerlink" title="Capacity"></a>Capacity</h3><p>缓冲区的 <code>capacity</code> 表明可以储存在缓冲区中的最大数据容量。实际上，它指定了底层数组的大小 ― 或者至少是指定了准许我们使用的底层数组的容量。</p><p><code>limit</code> 决不能大于 <code>capacity</code>。</p><h3 id="观察变量"><a href="#观察变量" class="headerlink" title="观察变量"></a>观察变量</h3><p>我们首先观察一个新创建的缓冲区。出于本例子的需要，我们假设这个缓冲区的 <code>总容量</code>为8个字节。 <code>Buffer</code> 的状态如下所示：</p><h5 id="回想一下-，limit-决不能大于-capacity，此例中这两个值都被设置为-8。我们通过将它们指向数组的尾部之后-如果有第8个槽，则是第8个槽所在的位置-来说明这点。"><a href="#回想一下-，limit-决不能大于-capacity，此例中这两个值都被设置为-8。我们通过将它们指向数组的尾部之后-如果有第8个槽，则是第8个槽所在的位置-来说明这点。" class="headerlink" title="回想一下 ，limit 决不能大于 capacity，此例中这两个值都被设置为 8。我们通过将它们指向数组的尾部之后(如果有第8个槽，则是第8个槽所在的位置)来说明这点。"></a><img src="https://img.guitu18.com/markdown/974dfb67bb638b7e589e0503e61be06f.gif" alt="Buffer state">回想一下 ，<code>limit</code> 决不能大于 <code>capacity</code>，此例中这两个值都被设置为 8。我们通过将它们指向数组的尾部之后(如果有第8个槽，则是第8个槽所在的位置)来说明这点。</h5><h5 id="position-设置为0。如果我们读一些数据到缓冲区中，那么下一个读取的数据就进入-slot-0-。如果我们从缓冲区写一些数据，从缓冲区读取的下一个字节就来自-slot-0-。-position-设置如下所示："><a href="#position-设置为0。如果我们读一些数据到缓冲区中，那么下一个读取的数据就进入-slot-0-。如果我们从缓冲区写一些数据，从缓冲区读取的下一个字节就来自-slot-0-。-position-设置如下所示：" class="headerlink" title="position 设置为0。如果我们读一些数据到缓冲区中，那么下一个读取的数据就进入 slot 0 。如果我们从缓冲区写一些数据，从缓冲区读取的下一个字节就来自 slot 0 。 position 设置如下所示："></a><img src="https://img.guitu18.com/markdown/9ca400795816cd8148a415dd291bb55f.gif" alt="Array"><code>position</code> 设置为0。如果我们读一些数据到缓冲区中，那么下一个读取的数据就进入 slot 0 。如果我们从缓冲区写一些数据，从缓冲区读取的下一个字节就来自 slot 0 。 <code>position</code> 设置如下所示：</h5><h5 id="由于-capacity-不会改变，所以我们在下面的讨论中可以忽略它。"><a href="#由于-capacity-不会改变，所以我们在下面的讨论中可以忽略它。" class="headerlink" title="由于 capacity 不会改变，所以我们在下面的讨论中可以忽略它。"></a><img src="https://img.guitu18.com/markdown/5f855b264d50d852e555393fbd5588cc.gif" alt="Position setting">由于 <code>capacity</code> 不会改变，所以我们在下面的讨论中可以忽略它。</h5><h3 id="第一次读取"><a href="#第一次读取" class="headerlink" title="第一次读取"></a>第一次读取</h3><p>现在我们可以开始在新创建的缓冲区上进行读/写操作。首先从输入通道中读一些数据到缓冲区中。第一次读取得到三个字节。它们被放到数组中从 <code>position</code> 开始的位置，这时 position 被设置为 0。读完之后，position 就增加到 3，如下所示：</p><h5 id="limit-没有改变。"><a href="#limit-没有改变。" class="headerlink" title="limit 没有改变。"></a><img src="https://img.guitu18.com/markdown/e88a24821db310464d8a08992568ef37.gif" alt="Position increased to 3"><code>limit</code> 没有改变。</h5><h3 id="第二次读取"><a href="#第二次读取" class="headerlink" title="第二次读取"></a>第二次读取</h3><p>在第二次读取时，我们从输入通道读取另外两个字节到缓冲区中。这两个字节储存在由 <code>position</code> 所指定的位置上， <code>position</code>因而增加 2：</p><h5 id="limit-没有改变。-1"><a href="#limit-没有改变。-1" class="headerlink" title="limit 没有改变。"></a><img src="https://img.guitu18.com/markdown/ef3aaadc4fa8aae9a47ace7811408260.gif" alt="Position increased by 2"><code>limit</code> 没有改变。</h5><h3 id="flip"><a href="#flip" class="headerlink" title="flip"></a>flip</h3><p>现在我们要将数据写到输出通道中。在这之前，我们必须调用 <code>flip()</code> 方法。这个方法做两件非常重要的事：</p><ol><li>它将 <code>limit</code> 设置为当前 <code>position</code>。</li><li>它将 <code>position</code> 设置为 0。</li></ol><p>前一小节中的图显示了在 flip 之前缓冲区的情况。下面是在 flip 之后的缓冲区：</p><h5 id="我们现在可以将数据从缓冲区写入通道了。-position-被设置为-0，这意味着我们得到的下一个字节是第一个字节。-limit-已被设置为原来的-position，这意味着它包括以前读到的所有字节，并且一个字节也不多。"><a href="#我们现在可以将数据从缓冲区写入通道了。-position-被设置为-0，这意味着我们得到的下一个字节是第一个字节。-limit-已被设置为原来的-position，这意味着它包括以前读到的所有字节，并且一个字节也不多。" class="headerlink" title="我们现在可以将数据从缓冲区写入通道了。 position 被设置为 0，这意味着我们得到的下一个字节是第一个字节。 limit 已被设置为原来的 position，这意味着它包括以前读到的所有字节，并且一个字节也不多。"></a><img src="https://img.guitu18.com/markdown/f416bdb984e2f1f2c299f9a18088ffbf.gif" alt="Buffer after the flip">我们现在可以将数据从缓冲区写入通道了。 <code>position</code> 被设置为 0，这意味着我们得到的下一个字节是第一个字节。 <code>limit</code> 已被设置为原来的 <code>position</code>，这意味着它包括以前读到的所有字节，并且一个字节也不多。</h5><h3 id="第一次写入"><a href="#第一次写入" class="headerlink" title="第一次写入"></a>第一次写入</h3><p>在第一次写入时，我们从缓冲区中取四个字节并将它们写入输出通道。这使得 <code>position</code> 增加到 4，而 <code>limit</code> 不变，如下所示：</p><h5><a href="#" class="headerlink"></a><img src="https://img.guitu18.com/markdown/e435d53b79b7d5056659266449b94ac2.gif" alt="Position advanced to 4, limit unchanged"></h5><h3 id="第二次写入"><a href="#第二次写入" class="headerlink" title="第二次写入"></a>第二次写入</h3><p>我们只剩下一个字节可写了。 <code>limit</code>在我们调用 <code>flip()</code> 时被设置为 5，并且 <code>position</code> 不能超过 <code>limit</code>。所以最后一次写入操作从缓冲区取出一个字节并将它写入输出通道。这使得 <code>position</code> 增加到 5，并保持 <code>limit</code> 不变，如下所示：</p><h5 id="-1"><a href="#-1" class="headerlink"></a><img src="https://img.guitu18.com/markdown/3453374e843eac43b526d06b12f8b741.gif" alt="Position advanced to 5, limit unchanged"></h5><h3 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h3><p>最后一步是调用缓冲区的 <code>clear()</code> 方法。这个方法重设缓冲区以便接收更多的字节。 <code>Clear</code> 做两种非常重要的事情：</p><ol><li>它将 <code>limit</code> 设置为与 <code>capacity</code> 相同。</li><li>它设置 <code>position</code> 为 0。</li></ol><p>下图显示了在调用 <code>clear()</code> 后缓冲区的状态：</p><h5 id="缓冲区现在可以接收新的数据了。"><a href="#缓冲区现在可以接收新的数据了。" class="headerlink" title="缓冲区现在可以接收新的数据了。"></a><img src="https://img.guitu18.com/markdown/25b36164d49a2ec4d1d4ff4dd52fa7ea.gif" alt="State of the buffer after clear() has been called">缓冲区现在可以接收新的数据了。</h5><h3 id="访问方法"><a href="#访问方法" class="headerlink" title="访问方法"></a>访问方法</h3><p>到目前为止，我们只是使用缓冲区将数据从一个通道转移到另一个通道。然而，程序经常需要直接处理数据。例如，您可能需要将用户数据保存到磁盘。在这种情况下，您必须将这些数据直接放入缓冲区，然后用通道将缓冲区写入磁盘。</p><p>或者，您可能想要从磁盘读取用户数据。在这种情况下，您要将数据从通道读到缓冲区中，然后检查缓冲区中的数据。</p><p>在本节的最后，我们将详细分析如何使用 <code>ByteBuffer</code> 类的 <code>get()</code> 和 <code>put()</code> 方法直接访问缓冲区中的数据。</p><h3 id="get-方法"><a href="#get-方法" class="headerlink" title="get() 方法"></a>get() 方法</h3><p><code>ByteBuffer</code> 类中有四个 <code>get()</code> 方法：</p><ol><li><code>byte get();</code></li><li><code>ByteBuffer get( byte dst[] );</code></li><li><code>ByteBuffer get( byte dst[], int offset, int length );</code></li><li><code>byte get( int index );</code></li></ol><p>第一个方法获取单个字节。第二和第三个方法将一组字节读到一个数组中。第四个方法从缓冲区中的特定位置获取字节。那些返回 <code>ByteBuffer</code> 的方法只是返回调用它们的缓冲区的 <code>this</code> 值。</p><p>此外，我们认为前三个 <code>get()</code> 方法是相对的，而最后一个方法是绝对的。 <em>相对</em> 意味着 <code>get()</code> 操作服从 <code>limit</code> 和 <code>position</code> 值 ― 更明确地说，字节是从当前 <code>position</code> 读取的，而 <code>position</code> 在 <code>get</code> 之后会增加。另一方面，一个 <em>绝对</em> 方法会忽略 <code>limit</code>和 <code>position</code> 值，也不会影响它们。事实上，它完全绕过了缓冲区的统计方法。</p><p>上面列出的方法对应于 <code>ByteBuffer</code> 类。其他类有等价的 <code>get()</code> 方法，这些方法除了不是处理字节外，其它方面是是完全一样的，它们处理的是与该缓冲区类相适应的类型。</p><h3 id="put-方法"><a href="#put-方法" class="headerlink" title="put()方法"></a>put()方法</h3><p><code>ByteBuffer</code> 类中有五个 <code>put()</code> 方法：</p><ol><li><code>ByteBuffer put( byte b );</code></li><li><code>ByteBuffer put( byte src[] );</code></li><li><code>ByteBuffer put( byte src[], int offset, int length );</code></li><li><code>ByteBuffer put( ByteBuffer src );</code></li><li><code>ByteBuffer put( int index, byte b );</code></li></ol><p>第一个方法 <code>写入（put）</code>单个字节。第二和第三个方法写入来自一个数组的一组字节。第四个方法将数据从一个给定的源<code>ByteBuffer</code> 写入这个 <code>ByteBuffer</code>。第五个方法将字节写入缓冲区中特定的 <code>位置</code>。那些返回 <code>ByteBuffer</code> 的方法只是返回调用它们的缓冲区的 <code>this</code> 值。</p><p>与 <code>get()</code> 方法一样，我们将把 <code>put()</code> 方法划分为 <em>相对</em> 或者 <em>绝对</em> 的。前四个方法是相对的，而第五个方法是绝对的。</p><p>上面显示的方法对应于 <code>ByteBuffer</code> 类。其他类有等价的 <code>put()</code> 方法，这些方法除了不是处理字节之外，其它方面是完全一样的。它们处理的是与该缓冲区类相适应的类型。</p><h3 id="类型化的-get-和-put-方法"><a href="#类型化的-get-和-put-方法" class="headerlink" title="类型化的 get() 和 put() 方法"></a>类型化的 get() 和 put() 方法</h3><p>除了前些小节中描述的 <code>get()</code> 和 <code>put()</code> 方法， <code>ByteBuffer</code> 还有用于读写不同类型的值的其他方法，如下所示：</p><ul><li><code>getByte()</code></li><li><code>getChar()</code></li><li><code>getShort()</code></li><li><code>getInt()</code></li><li><code>getLong()</code></li><li><code>getFloat()</code></li><li><code>getDouble()</code></li><li><code>putByte()</code></li><li><code>putChar()</code></li><li><code>putShort()</code></li><li><code>putInt()</code></li><li><code>putLong()</code></li><li><code>putFloat()</code></li><li><code>putDouble()</code></li></ul><p>事实上，这其中的每个方法都有两种类型 ― 一种是相对的，另一种是绝对的。它们对于读取格式化的二进制数据（如图像文件的头部）很有用。</p><p>您可以在例子程序 TypesInByteBuffer.java 中看到这些方法的实际应用。</p><h3 id="缓冲区的使用：一个内部循环"><a href="#缓冲区的使用：一个内部循环" class="headerlink" title="缓冲区的使用：一个内部循环"></a>缓冲区的使用：一个内部循环</h3><p>下面的内部循环概括了使用缓冲区将数据从输入通道拷贝到输出通道的过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">     buffer.clear();</span><br><span class="line">     <span class="keyword">int</span> r = fcin.read( buffer );</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">if</span> (r==-<span class="number">1</span>) &#123;</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     buffer.flip();</span><br><span class="line">     fcout.write( buffer );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>read()</code> 和 <code>write()</code> 调用得到了极大的简化，因为许多工作细节都由缓冲区完成了。 <code>clear()</code> 和 <code>flip()</code> 方法用于让缓冲区在读和写之间切换。</p><h2 id="关于缓冲区的更多内容"><a href="#关于缓冲区的更多内容" class="headerlink" title="关于缓冲区的更多内容"></a>关于缓冲区的更多内容</h2><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><p>到目前为止，您已经学习了使用缓冲区进行日常工作所需要掌握的大部分内容。我们的例子没怎么超出标准的读/写过程种类，在原来的 I/O 中可以像在 NIO 中一样容易地实现这样的标准读写过程。</p><p>本节将讨论使用缓冲区的一些更复杂的方面，比如缓冲区分配、包装和分片。我们还会讨论 NIO 带给 Java 平台的一些新功能。您将学到如何创建不同类型的缓冲区以达到不同的目的，如可保护数据不被修改的 <em>只读</em> 缓冲区，和直接映射到底层操作系统缓冲区的 <em>直接</em> 缓冲区。我们将在本节的最后介绍如何在 NIO 中创建内存映射文件。</p><h3 id="缓冲区分配和包装"><a href="#缓冲区分配和包装" class="headerlink" title="缓冲区分配和包装"></a>缓冲区分配和包装</h3><p>在能够读和写之前，必须有一个缓冲区。要创建缓冲区，您必须 <em>分配</em> 它。我们使用静态方法 <code>allocate()</code> 来分配缓冲区：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buffer = ByteBuffer.allocate( <span class="number">1024</span> );</span><br></pre></td></tr></table></figure><p><code>allocate()</code> 方法分配一个具有指定大小的底层数组，并将它包装到一个缓冲区对象中 ― 在本例中是一个 <code>ByteBuffer</code>。</p><p>您还可以将一个现有的数组转换为缓冲区，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> array[] = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">ByteBuffer buffer = ByteBuffer.wrap( array );</span><br></pre></td></tr></table></figure><p>本例使用了 <code>wrap()</code> 方法将一个数组包装为缓冲区。必须非常小心地进行这类操作。一旦完成包装，底层数据就可以通过缓冲区或者直接访问。</p><h3 id="缓冲区分片"><a href="#缓冲区分片" class="headerlink" title="缓冲区分片"></a>缓冲区分片</h3><p><code>slice()</code> 方法根据现有的缓冲区创建一种 <em>子缓冲区</em> 。也就是说，它创建一个新的缓冲区，新缓冲区与原来的缓冲区的一部分共享数据。</p><p>使用例子可以最好地说明这点。让我们首先创建一个长度为 10 的 <code>ByteBuffer</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buffer = ByteBuffer.allocate( <span class="number">10</span> );</span><br></pre></td></tr></table></figure><p>然后使用数据来填充这个缓冲区，在第 <em>n</em> 个槽中放入数字 <em>n</em>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;buffer.capacity(); ++i) &#123;</span><br><span class="line">     buffer.put( (<span class="keyword">byte</span>)i );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们对这个缓冲区 <em>分片</em> ，以创建一个包含槽 3 到槽 6 的子缓冲区。在某种意义上，子缓冲区就像原来的缓冲区中的一个<em>窗口</em> 。</p><p>窗口的起始和结束位置通过设置 <code>position</code> 和 <code>limit</code> 值来指定，然后调用 <code>Buffer</code> 的 <code>slice()</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">buffer.position( <span class="number">3</span> );</span><br><span class="line">buffer.limit( <span class="number">7</span> );</span><br><span class="line">ByteBuffer slice = buffer.slice();</span><br></pre></td></tr></table></figure><p><code>片</code>是缓冲区的 <code>子缓冲区</code>。不过， <code>片段</code>和 <code>缓冲区</code>共享同一个底层数据数组，我们在下一节将会看到这一点。</p><h3 id="缓冲区份片和数据共享"><a href="#缓冲区份片和数据共享" class="headerlink" title="缓冲区份片和数据共享"></a>缓冲区份片和数据共享</h3><p>我们已经创建了原缓冲区的子缓冲区，并且我们知道缓冲区和子缓冲区共享同一个底层数据数组。让我们看看这意味着什么。</p><p>我们遍历子缓冲区，将每一个元素乘以 11 来改变它。例如，5 会变成 55。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;slice.capacity(); ++i) &#123;</span><br><span class="line">     <span class="keyword">byte</span> b = slice.get( i );</span><br><span class="line">     b *= <span class="number">11</span>;</span><br><span class="line">     slice.put( i, b );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，再看一下原缓冲区中的内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">buffer.position( <span class="number">0</span> );</span><br><span class="line">buffer.limit( buffer.capacity() );</span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> (buffer.remaining()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">     System.out.println( buffer.get() );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果表明只有在子缓冲区窗口中的元素被改变了：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ java SliceBuffer</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">33</span></span><br><span class="line"><span class="number">44</span></span><br><span class="line"><span class="number">55</span></span><br><span class="line"><span class="number">66</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure><p>缓冲区片对于促进抽象非常有帮助。可以编写自己的函数处理整个缓冲区，而且如果想要将这个过程应用于子缓冲区上，您只需取主缓冲区的一个片，并将它传递给您的函数。这比编写自己的函数来取额外的参数以指定要对缓冲区的哪一部分进行操作更容易。</p><h3 id="只读缓冲区"><a href="#只读缓冲区" class="headerlink" title="只读缓冲区"></a>只读缓冲区</h3><p>只读缓冲区非常简单 ― 您可以读取它们，但是不能向它们写入。可以通过调用缓冲区的 <code>asReadOnlyBuffer()</code> 方法，将任何常规缓冲区转换为只读缓冲区，这个方法返回一个与原缓冲区完全相同的缓冲区(并与其共享数据)，只不过它是只读的。</p><p>只读缓冲区对于保护数据很有用。在将缓冲区传递给某个对象的方法时，您无法知道这个方法是否会修改缓冲区中的数据。创建一个只读的缓冲区可以 <em>保证</em> 该缓冲区不会被修改。</p><p>不能将只读的缓冲区转换为可写的缓冲区。</p><h3 id="直接和间接缓冲区"><a href="#直接和间接缓冲区" class="headerlink" title="直接和间接缓冲区"></a>直接和间接缓冲区</h3><p>另一种有用的 <code>ByteBuffer</code> 是直接缓冲区。 <em>直接缓冲区</em> 是为加快 I/O 速度，而以一种特殊的方式分配其内存的缓冲区。</p><p>实际上，直接缓冲区的准确定义是与实现相关的。Sun 的文档是这样描述直接缓冲区的：</p><p><em>给定一个直接字节缓冲区，Java 虚拟机将尽最大努力直接对它执行本机 I/O 操作。也就是说，它会在每一次调用底层操作系统的本机 I/O 操作之前(或之后)，尝试避免将缓冲区的内容拷贝到一个中间缓冲区中(或者从一个中间缓冲区中拷贝数据)。</em></p><p>您可以在例子程序 FastCopyFile.java 中看到直接缓冲区的实际应用，这个程序是 CopyFile.java 的另一个版本，它使用了直接缓冲区以提高速度。</p><p>还可以用内存映射文件创建直接缓冲区。</p><h3 id="内存映射文件-I-O"><a href="#内存映射文件-I-O" class="headerlink" title="内存映射文件 I/O"></a>内存映射文件 I/O</h3><p>内存映射文件 I/O 是一种读和写文件数据的方法，它可以比常规的基于流或者基于通道的 I/O 快得多。</p><p>内存映射文件 I/O 是通过使文件中的数据神奇般地出现为内存数组的内容来完成的。这其初听起来似乎不过就是将整个文件读到内存中，但是事实上并不是这样。一般来说，只有文件中实际读取或者写入的部分才会送入（或者 <em>映射</em> ）到内存中。</p><p>内存映射并不真的神奇或者多么不寻常。现代操作系统一般根据需要将文件的部分映射为内存的部分，从而实现文件系统。Java 内存映射机制不过是在底层操作系统中可以采用这种机制时，提供了对该机制的访问。</p><p>尽管创建内存映射文件相当简单，但是向它写入可能是危险的。仅只是改变数组的单个元素这样的简单操作，就可能会直接修改磁盘上的文件。修改数据与将数据保存到磁盘是没有分开的。</p><h3 id="将文件映射到内存"><a href="#将文件映射到内存" class="headerlink" title="将文件映射到内存"></a>将文件映射到内存</h3><p>了解内存映射的最好方法是使用例子。在下面的例子中，我们要将一个 <code>FileChannel</code> (它的全部或者部分)映射到内存中。为此我们将使用 <code>FileChannel.map()</code> 方法。下面代码行将文件的前 1024 个字节映射到内存中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MappedByteBuffer mbb = fc.map( FileChannel.MapMode.READ_WRITE, <span class="number">0</span>, <span class="number">1024</span> );</span><br></pre></td></tr></table></figure><p><code>map()</code> 方法返回一个 <code>MappedByteBuffer</code>，它是 <code>ByteBuffer</code> 的子类。因此，您可以像使用其他任何 <code>ByteBuffer</code> 一样使用新映射的缓冲区，操作系统会在需要时负责执行行映射。</p><h2 id="分散和聚集"><a href="#分散和聚集" class="headerlink" title="分散和聚集"></a>分散和聚集</h2><h3 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h3><p>分散/聚集 I/O 是使用多个而不是单个缓冲区来保存数据的读写方法。</p><p>一个分散的读取就像一个常规通道读取，只不过它是将数据读到一个缓冲区数组中而不是读到单个缓冲区中。同样地，一个聚集写入是向缓冲区数组而不是向单个缓冲区写入数据。</p><p>分散/聚集 I/O 对于将数据流划分为单独的部分很有用，这有助于实现复杂的数据格式。</p><h3 id="分散-聚集-I-O"><a href="#分散-聚集-I-O" class="headerlink" title="分散/聚集 I/O"></a>分散/聚集 I/O</h3><p>通道可以有选择地实现两个新的接口： <code>ScatteringByteChannel</code> 和 <code>GatheringByteChannel</code>。一个 <code>ScatteringByteChannel</code>是一个具有两个附加读方法的通道：</p><ul><li><code>long read( ByteBuffer[] dsts );</code></li><li><code>long read( ByteBuffer[] dsts, int offset, int length );</code></li></ul><p>这些 <code>long read()</code> 方法很像标准的 <code>read</code> 方法，只不过它们不是取单个缓冲区而是取一个缓冲区数组。</p><p>在 <em>分散读取</em> 中，通道依次填充每个缓冲区。填满一个缓冲区后，它就开始填充下一个。在某种意义上，缓冲区数组就像一个大缓冲区。</p><h3 id="分散-聚集的应用"><a href="#分散-聚集的应用" class="headerlink" title="分散/聚集的应用"></a>分散/聚集的应用</h3><p>分散/聚集 I/O 对于将数据划分为几个部分很有用。例如，您可能在编写一个使用消息对象的网络应用程序，每一个消息被划分为固定长度的头部和固定长度的正文。您可以创建一个刚好可以容纳头部的缓冲区和另一个刚好可以容难正文的缓冲区。当您将它们放入一个数组中并使用分散读取来向它们读入消息时，头部和正文将整齐地划分到这两个缓冲区中。</p><p>我们从缓冲区所得到的方便性对于缓冲区数组同样有效。因为每一个缓冲区都跟踪自己还可以接受多少数据，所以分散读取会自动找到有空间接受数据的第一个缓冲区。在这个缓冲区填满后，它就会移动到下一个缓冲区。</p><h3 id="聚集写入"><a href="#聚集写入" class="headerlink" title="聚集写入"></a>聚集写入</h3><p><em>聚集写入</em> 类似于分散读取，只不过是用来写入。它也有接受缓冲区数组的方法：</p><ul><li><code>long write( ByteBuffer[] srcs );</code></li><li><code>long write( ByteBuffer[] srcs, int offset, int length );</code></li></ul><p>聚集写对于把一组单独的缓冲区中组成单个数据流很有用。为了与上面的消息例子保持一致，您可以使用聚集写入来自动将网络消息的各个部分组装为单个数据流，以便跨越网络传输消息。</p><p>从例子程序 UseScatterGather.java 中可以看到分散读取和聚集写入的实际应用。</p><h2 id="文件锁定"><a href="#文件锁定" class="headerlink" title="文件锁定"></a>文件锁定</h2><h3 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h3><p>文件锁定初看起来可能让人迷惑。它 <em>似乎</em> 指的是防止程序或者用户访问特定文件。事实上，文件锁就像常规的 Java 对象锁 ― 它们是 <em>劝告式的（advisory）</em> 锁。它们不阻止任何形式的数据访问，相反，它们通过锁的共享和获取赖允许系统的不同部分相互协调。</p><p>您可以锁定整个文件或者文件的一部分。如果您获取一个排它锁，那么其他人就不能获得同一个文件或者文件的一部分上的锁。如果您获得一个共享锁，那么其他人可以获得同一个文件或者文件一部分上的共享锁，但是不能获得排它锁。文件锁定并不总是出于保护数据的目的。例如，您可能临时锁定一个文件以保证特定的写操作成为原子的，而不会有其他程序的干扰。</p><p>大多数操作系统提供了文件系统锁，但是它们并不都是采用同样的方式。有些实现提供了共享锁，而另一些仅提供了排它锁。事实上，有些实现使得文件的锁定部分不可访问，尽管大多数实现不是这样的。</p><p>在本节中，您将学习如何在 NIO 中执行简单的文件锁过程，我们还将探讨一些保证被锁定的文件尽可能可移植的方法。</p><h3 id="锁定文件"><a href="#锁定文件" class="headerlink" title="锁定文件"></a>锁定文件</h3><p>要获取文件的一部分上的锁，您要调用一个打开的 <code>FileChannel</code> 上的 <code>lock()</code> 方法。注意，如果要获取一个排它锁，您必须以写方式打开文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile raf = <span class="keyword">new</span> RandomAccessFile( <span class="string">"usefilelocks.txt"</span>, <span class="string">"rw"</span> );</span><br><span class="line">FileChannel fc = raf.getChannel();</span><br><span class="line">FileLock lock = fc.lock( start, end, <span class="keyword">false</span> );</span><br></pre></td></tr></table></figure><p>在拥有锁之后，您可以执行需要的任何敏感操作，然后再释放锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock.release();</span><br></pre></td></tr></table></figure><p>在释放锁后，尝试获得锁的其他任何程序都有机会获得它。</p><p>本小节的例子程序 UseFileLocks.java 必须与它自己并行运行。这个程序获取一个文件上的锁，持有三秒钟，然后释放它。如果同时运行这个程序的多个实例，您会看到每个实例依次获得锁。</p><h3 id="文件锁定和可移植性"><a href="#文件锁定和可移植性" class="headerlink" title="文件锁定和可移植性"></a>文件锁定和可移植性</h3><p>文件锁定可能是一个复杂的操作，特别是考虑到不同的操作系统是以不同的方式实现锁这一事实。下面的指导原则将帮助您尽可能保持代码的可移植性：</p><ul><li>只使用排它锁。</li><li>将所有的锁视为劝告式的（advisory）。</li></ul><h2 id="连网和异步-I-O"><a href="#连网和异步-I-O" class="headerlink" title="连网和异步 I/O"></a>连网和异步 I/O</h2><h3 id="概述-6"><a href="#概述-6" class="headerlink" title="概述"></a>概述</h3><p>连网是学习异步 I/O 的很好基础，而异步 I/O 对于在 Java 语言中执行任何输入/输出过程的人来说，无疑都是必须具备的知识。NIO 中的连网与 NIO 中的其他任何操作没有什么不同 ― 它依赖通道和缓冲区，而您通常使用 <code>InputStream</code> 和<code>OutputStream</code> 来获得通道。</p><p>本节首先介绍异步 I/O 的基础 ― 它是什么以及它不是什么，然后转向更实用的、程序性的例子。</p><h3 id="异步-I-O"><a href="#异步-I-O" class="headerlink" title="异步 I/O"></a>异步 I/O</h3><p>异步 I/O 是一种 <em>没有阻塞地</em> 读写数据的方法。通常，在代码进行 <code>read()</code> 调用时，代码会阻塞直至有可供读取的数据。同样， <code>write()</code> 调用将会阻塞直至数据能够写入。</p><p>另一方面，异步 I/O 调用不会阻塞。相反，您将注册对特定 I/O 事件的兴趣 ― 可读的数据的到达、新的套接字连接，等等，而在发生这样的事件时，系统将会告诉您。</p><p>异步 I/O 的一个优势在于，它允许您同时根据大量的输入和输出执行 I/O。同步程序常常要求助于轮询，或者创建许许多多的线程以处理大量的连接。使用异步 I/O，您可以监听任何数量的通道上的事件，不用轮询，也不用额外的线程。</p><p>我们将通过研究一个名为 MultiPortEcho.java 的例子程序来查看异步 I/O 的实际应用。这个程序就像传统的 <em>echo server</em>，它接受网络连接并向它们回响它们可能发送的数据。不过它有一个附加的特性，就是它能同时监听多个端口，并处理来自所有这些端口的连接。并且它只在单个线程中完成所有这些工作。</p><h3 id="Selectors"><a href="#Selectors" class="headerlink" title="Selectors"></a>Selectors</h3><p>本节的阐述对应于 <code>MultiPortEcho</code> 的源代码中的 <code>go()</code> 方法的实现，因此应该看一下源代码，以便对所发生的事情有个更全面的了解。</p><p>异步 I/O 中的核心对象名为 <code>Selector</code>。<code>Selector</code> 就是您注册对各种 I/O 事件的兴趣的地方，而且当那些事件发生时，就是这个对象告诉您所发生的事件。</p><p>所以，我们需要做的第一件事就是创建一个 <code>Selector</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Selector selector = Selector.open();</span><br></pre></td></tr></table></figure><p>然后，我们将对不同的通道对象调用 <code>register()</code> 方法，以便注册我们对这些对象中发生的 I/O 事件的兴趣。<code>register()</code> 的第一个参数总是这个 <code>Selector</code>。</p><h3 id="打开一个-ServerSocketChannel"><a href="#打开一个-ServerSocketChannel" class="headerlink" title="打开一个 ServerSocketChannel"></a>打开一个 ServerSocketChannel</h3><p>为了接收连接，我们需要一个 <code>ServerSocketChannel</code>。事实上，我们要监听的每一个端口都需要有一个<code>ServerSocketChannel</code> 。对于每一个端口，我们打开一个 <code>ServerSocketChannel</code>，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ServerSocketChannel ssc = ServerSocketChannel.open();</span><br><span class="line">ssc.configureBlocking( <span class="keyword">false</span> );</span><br><span class="line"> </span><br><span class="line">ServerSocket ss = ssc.socket();</span><br><span class="line">InetSocketAddress address = <span class="keyword">new</span> InetSocketAddress( ports[i] );</span><br><span class="line">ss.bind( address );</span><br></pre></td></tr></table></figure><p>第一行创建一个新的 <code>ServerSocketChannel</code> ，最后三行将它绑定到给定的端口。第二行将 <code>ServerSocketChannel</code> 设置为 <em>非阻塞的</em> 。我们必须对每一个要使用的套接字通道调用这个方法，否则异步 I/O 就不能工作。</p><h3 id="选择键"><a href="#选择键" class="headerlink" title="选择键"></a>选择键</h3><p>下一步是将新打开的 <code>ServerSocketChannels</code> 注册到 <code>Selector</code>上。为此我们使用 ServerSocketChannel.register() 方法，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SelectionKey key = ssc.register( selector, SelectionKey.OP_ACCEPT );</span><br></pre></td></tr></table></figure><p><code>register()</code> 的第一个参数总是这个 <code>Selector</code>。第二个参数是 <code>OP_ACCEPT</code>，这里它指定我们想要监听 <em>accept</em> 事件，也就是在新的连接建立时所发生的事件。这是适用于 <code>ServerSocketChannel</code> 的唯一事件类型。</p><p>请注意对 <code>register()</code> 的调用的返回值。 <code>SelectionKey</code> 代表这个通道在此 <code>Selector</code> 上的这个注册。当某个 <code>Selector</code> 通知您某个传入事件时，它是通过提供对应于该事件的 <code>SelectionKey</code> 来进行的。<code>SelectionKey</code> 还可以用于取消通道的注册。</p><h3 id="内部循环"><a href="#内部循环" class="headerlink" title="内部循环"></a>内部循环</h3><p>现在已经注册了我们对一些 I/O 事件的兴趣，下面将进入主循环。使用 <code>Selectors</code> 的几乎每个程序都像下面这样使用内部循环：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = selector.select();</span><br><span class="line"> </span><br><span class="line">Set selectedKeys = selector.selectedKeys();</span><br><span class="line">Iterator it = selectedKeys.iterator();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">     SelectionKey key = (SelectionKey)it.next();</span><br><span class="line">     <span class="comment">// ... deal with I/O event ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，我们调用 <code>Selector</code> 的 <code>select()</code> 方法。这个方法会阻塞，直到至少有一个已注册的事件发生。当一个或者更多的事件发生时， <code>select()</code> 方法将返回所发生的事件的数量。</p><p>接下来，我们调用 <code>Selector</code> 的 <code>selectedKeys()</code> 方法，它返回发生了事件的 <code>SelectionKey</code> 对象的一个 <code>集合</code>。</p><p>我们通过迭代 <code>SelectionKeys</code> 并依次处理每个 <code>SelectionKey</code> 来处理事件。对于每一个 <code>SelectionKey</code>，您必须确定发生的是什么 I/O 事件，以及这个事件影响哪些 I/O 对象。</p><h3 id="监听新连接"><a href="#监听新连接" class="headerlink" title="监听新连接"></a>监听新连接</h3><p>程序执行到这里，我们仅注册了 <code>ServerSocketChannel</code>，并且仅注册它们“接收”事件。为确认这一点，我们对 <code>SelectionKey</code>调用 <code>readyOps()</code> 方法，并检查发生了什么类型的事件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((key.readyOps() &amp; SelectionKey.OP_ACCEPT)</span><br><span class="line">     == SelectionKey.OP_ACCEPT) &#123;</span><br><span class="line"> </span><br><span class="line">     <span class="comment">// Accept the new connection</span></span><br><span class="line">     <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以肯定地说， <code>readOps()</code> 方法告诉我们该事件是新的连接。</p><h3 id="接受新的连接"><a href="#接受新的连接" class="headerlink" title="接受新的连接"></a>接受新的连接</h3><p>因为我们知道这个服务器套接字上有一个传入连接在等待，所以可以安全地接受它；也就是说，不用担心 <code>accept()</code> 操作会阻塞：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ServerSocketChannel ssc = (ServerSocketChannel)key.channel();</span><br><span class="line">SocketChannel sc = ssc.accept();</span><br></pre></td></tr></table></figure><p>下一步是将新连接的 <code>SocketChannel</code> 配置为非阻塞的。而且由于接受这个连接的目的是为了读取来自套接字的数据，所以我们还必须将 <code>SocketChannel</code> 注册到 <code>Selector</code>上，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sc.configureBlocking( <span class="keyword">false</span> );</span><br><span class="line">SelectionKey newKey = sc.register( selector, SelectionKey.OP_READ );</span><br></pre></td></tr></table></figure><p>注意我们使用 <code>register()</code> 的 <code>OP_READ</code> 参数，将 <code>SocketChannel</code> 注册用于 <em>读取</em> 而不是 <em>接受</em> 新连接。</p><h3 id="删除处理过的-SelectionKey"><a href="#删除处理过的-SelectionKey" class="headerlink" title="删除处理过的 SelectionKey"></a>删除处理过的 SelectionKey</h3><p>在处理 <code>SelectionKey</code> 之后，我们几乎可以返回主循环了。但是我们必须首先将处理过的 <code>SelectionKey</code> 从选定的键集合中删除。如果我们没有删除处理过的键，那么它仍然会在主集合中以一个激活的键出现，这会导致我们尝试再次处理它。我们调用迭代器的 <code>remove()</code> 方法来删除处理过的 <code>SelectionKey</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">it.remove();</span><br></pre></td></tr></table></figure><p>现在我们可以返回主循环并接受从一个套接字中传入的数据(或者一个传入的 I/O 事件)了。</p><h3 id="传入的-I-O"><a href="#传入的-I-O" class="headerlink" title="传入的 I/O"></a>传入的 I/O</h3><p>当来自一个套接字的数据到达时，它会触发一个 I/O 事件。这会导致在主循环中调用 <code>Selector.select()</code>，并返回一个或者多个 I/O 事件。这一次， <code>SelectionKey</code> 将被标记为 <code>OP_READ</code> 事件，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ((key.readyOps() &amp; SelectionKey.OP_READ)</span><br><span class="line">     == SelectionKey.OP_READ) &#123;</span><br><span class="line">     <span class="comment">// Read the data</span></span><br><span class="line">     SocketChannel sc = (SocketChannel)key.channel();</span><br><span class="line">     <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与以前一样，我们取得发生 I/O 事件的通道并处理它。在本例中，由于这是一个 echo server，我们只希望从套接字中读取数据并马上将它发送回去。关于这个过程的细节，请参见 <a href="https://www.ibm.com/developerworks/cn/education/java/j-nio/j-nio.html#ma" target="_blank" rel="noopener">参考资料</a> 中的源代码 (MultiPortEcho.java)。</p><h3 id="回到主循环"><a href="#回到主循环" class="headerlink" title="回到主循环"></a>回到主循环</h3><p>每次返回主循环，我们都要调用 <code>select</code> 的 <code>Selector()</code>方法，并取得一组 <code>SelectionKey</code>。每个键代表一个 I/O 事件。我们处理事件，从选定的键集中删除 <code>SelectionKey</code>，然后返回主循环的顶部。</p><p>这个程序有点过于简单，因为它的目的只是展示异步 I/O 所涉及的技术。在现实的应用程序中，您需要通过将通道从<code>Selector</code> 中删除来处理关闭的通道。而且您可能要使用多个线程。这个程序可以仅使用一个线程，因为它只是一个演示，但是在现实场景中，创建一个线程池来负责 I/O 事件处理中的耗时部分会更有意义。</p><h2 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h2><h3 id="概述-7"><a href="#概述-7" class="headerlink" title="概述"></a>概述</h3><p>根据 Sun 的文档，一个 <code>Charset</code> 是“十六位 Unicode 字符序列与字节序列之间的一个命名的映射”。实际上，一个 <code>Charset</code> 允许您以尽可能最具可移植性的方式读写字符序列。</p><p>Java 语言被定义为基于 Unicode。然而在实际上，许多人编写代码时都假设一个字符在磁盘上或者在网络流中用一个字节表示。这种假设在许多情况下成立，但是并不是在所有情况下都成立，而且随着计算机变得对 Unicode 越来越友好，这个假设就日益变得不能成立了。</p><p>在本节中，我们将看一下如何使用 <code>Charsets</code> 以适合现代文本格式的方式处理文本数据。这里将使用的示例程序相当简单，不过，它触及了使用 <code>Charset</code> 的所有关键方面：为给定的字符编码创建 <code>Charset</code>，以及使用该 <code>Charset</code> 解码和编码文本数据。</p><h3 id="编码-解码"><a href="#编码-解码" class="headerlink" title="编码/解码"></a>编码/解码</h3><p>要读和写文本，我们要分别使用 <code>CharsetDecoder</code> 和 <code>CharsetEncoder</code>。将它们称为 <em>编码器</em> 和 <em>解码器</em> 是有道理的。一个 <em>字符</em> 不再表示一个特定的位模式，而是表示字符系统中的一个实体。因此，由某个实际的位模式表示的字符必须以某种特定的 <em>编码</em> 来表示。</p><p><code>CharsetDecoder</code> 用于将逐位表示的一串字符转换为具体的 <code>char</code> 值。同样，一个 <code>CharsetEncoder</code> 用于将字符转换回位。</p><p>在下一个小节中，我们将考察一个使用这些对象来读写数据的程序。</p><h3 id="处理文本的正确方式"><a href="#处理文本的正确方式" class="headerlink" title="处理文本的正确方式"></a>处理文本的正确方式</h3><p>现在我们将分析这个例子程序 UseCharsets.java。这个程序非常简单 ― 它从一个文件中读取一些文本，并将该文本写入另一个文件。但是它把该数据当作文本数据，并使用 <code>CharBuffer</code> 来将该数句读入一个 <code>CharsetDecoder</code> 中。同样，它使用 <code>CharsetEncoder</code> 来写回该数据。</p><p>我们将假设字符以 ISO-8859-1(Latin1) 字符集（这是 ASCII 的标准扩展）的形式储存在磁盘上。尽管我们必须为使用 Unicode 做好准备，但是也必须认识到不同的文件是以不同的格式储存的，而 ASCII 无疑是非常普遍的一种格式。事实上，每种 Java 实现都要求对以下字符编码提供完全的支持：</p><ul><li>US-ASCII</li><li>ISO-8859-1</li><li>UTF-8</li><li>UTF-16BE</li><li>UTF-16LE</li><li>UTF-16</li></ul><h3 id="示例程序"><a href="#示例程序" class="headerlink" title="示例程序"></a>示例程序</h3><p>在打开相应的文件、将输入数据读入名为 <code>inputData</code> 的 <code>ByteBuffer</code> 之后，我们的程序必须创建 ISO-8859-1 (Latin1) 字符集的一个实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Charset latin1 = Charset.forName( <span class="string">"ISO-8859-1"</span> );</span><br></pre></td></tr></table></figure><p>然后，创建一个解码器（用于读取）和一个编码器 （用于写入）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CharsetDecoder decoder = latin1.newDecoder();</span><br><span class="line">CharsetEncoder encoder = latin1.newEncoder();</span><br></pre></td></tr></table></figure><p>为了将字节数据解码为一组字符，我们把 <code>ByteBuffer</code> 传递给 <code>CharsetDecoder</code>，结果得到一个 <code>CharBuffer</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CharBuffer cb = decoder.decode( inputData );</span><br></pre></td></tr></table></figure><p>如果想要处理字符，我们可以在程序的此处进行。但是我们只想无改变地将它写回，所以没有什么要做的。</p><p>要写回数据，我们必须使用 <code>CharsetEncoder</code> 将它转换回字节：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer outputData = encoder.encode( cb );</span><br></pre></td></tr></table></figure><p>在转换完成之后，我们就可以将数据写到文件中了。</p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><h3 id="结束语-1"><a href="#结束语-1" class="headerlink" title="结束语"></a>结束语</h3><p>正如您所看到的， NIO 库有大量的特性。在一些新特性（例如文件锁定和字符集）提供新功能的同时，许多特性在优化方面也非常优秀。</p><p>在基础层次上，通道和缓冲区可以做的事情几乎都可以用原来的面向流的类来完成。但是通道和缓冲区允许以 <em>快得多</em> 的方式完成这些相同的旧操作 ― 事实上接近系统所允许的最大速度。</p><p>不过 NIO 最强大的长度之一在于，它提供了一种在 Java 语言中执行进行输入/输出的新的（也是迫切需要的）结构化方式。随诸如缓冲区、通道和异步 I/O 这些概念性（且可实现的）实体而来的，是我们重新思考 Java 程序中的 I/O过程的机会。这样，NIO 甚至为我们最熟悉的 I/O 过程也带来了新的活力，同时赋予我们通过和以前不同并且更好的方式执行它们的机会。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><p><a href="https://www.ibm.com/developerworks/cn/education/java/j-nio/nio-src.zip" target="_blank" rel="noopener">下载</a> 本教程中的例子的完整源代码。</p></li><li><p>关于安装和配置 JDK 1.4 的更多信息，请参见 <a href="http://java.sun.com/j2se/1.4.1/docs/index.html" target="_blank" rel="noopener">SDK 文档 </a>。</p></li><li><p><a href="http://java.sun.com/j2se/1.4.1/docs/guide/nio/index.html" target="_blank" rel="noopener">Sun’s guide to the new I/O APIs </a>提供了对 NIO 的全面介绍，包括一些本教程没有涵盖的细节内容。</p></li><li><p>在线 <a href="http://java.sun.com/j2se/1.4.1/docs/api/index.html" target="_blank" rel="noopener">API 规范 </a>描述了 NIO 的类和方法，该规范使用的是您了解并喜欢的 autodoc 格式。</p></li><li><p><a href="http://jcp.org/en/jsr/detail?id=051" target="_blank" rel="noopener">JSR 51 </a>是 Java Community Process 文档，它最先规定了 NIO 的新特性。事实上，JDK 1.4 中实现的 NIO 是该文档描述的特性的一个子集。</p></li><li><p>想获得关于流 I/O(包括问题、解决方案和 NIO 的介绍)的全面介绍吗？再没有比 Merlin Hughes 的”<a href="http://www.ibm.com/developerworks/java/library/j-io1/" target="_blank" rel="noopener">Turning streams inside out </a>“ (<em>developerWorks</em>，2002年7月)更好的了。</p></li><li><p>当然，还可以学习教程”<a href="http://www.ibm.com/developerworks/edu/j-javaio-i.html" target="_blank" rel="noopener">Introduction to Java I/O</a>“ (<em>developerWorks</em>，2000年4月)，它讨论了 JDK 1.4 之前的 Java I/O 的所有基础。</p></li><li><p>John Zukowski 在其 Merlin的魔力 专栏中撰写了一些关于 NIO 的优秀文章：</p><ul><li>“<a href="http://www.ibm.com/developerworks/java/library/j-mer03253.html" target="_blank" rel="noopener">“ The ins and outs of Merlin’s new I/O buffers “ </a>(<em>developerWorks</em>，2003年3月)是介绍缓冲区基本知识的另一篇文章。</li><li>“<a href="http://www.ibm.com/developerworks/java/library/j-mer1022.html" target="_blank" rel="noopener">“ Character sets “ </a>“ (<em>developerWorks</em>，2002年10月)专门讨论字符集（特别是转换和编码模式)。</li></ul></li><li><p>通过 Kalagnanam 和 Balu G 的 “<a href="http://www.ibm.com/developerworks/java/library/j-javaio/" target="_blank" rel="noopener">“ Merlin brings nonblocking I/O to the Java platform “</a> (<em>developerWorks</em>，2002年3月)进一步了解 NIO。</p></li><li><p>Greg Travis 在他的 “<a href="http://www.manning.com/travis/" target="_blank" rel="noopener"><em>JDK 1.4 Tutorial”</em> </a>(Manning 出版社，2002年3月)一书中仔细研究了 NIO。</p></li><li><p>您可以在 <a href="http://www.ibm.com/developerworks/java/" target="_blank" rel="noopener"><em>developerWorks</em> Java 技术专区 </a>找到数百篇关于 Java 编程的各个方面的文章。</p></li></ul><hr><blockquote><p>本文作者：Greg Travis<br>本文转自：<a href="https://www.ibm.com/developerworks/cn/education/java/j-nio/j-nio.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/education/java/j-nio/j-nio.html</a></p></blockquote></div><div class="reward-container"><div>明人不说暗话，如果你觉得可以的话，你懂的！</div><button disable="enable" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">打赏</button><div id="qr" style="display:none"><div style="display:inline-block"><img src="/images/wechatpay.jpg" alt="Guitu 微信支付"><p>微信支付</p></div><div style="display:inline-block"><img src="/images/alipay.jpg" alt="Guitu 支付宝"><p>支付宝</p></div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者： </strong>Guitu</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="https://www.guitu18.com/post/2019/05/18/34.html" title="NIO 入门">https://www.guitu18.com/post/2019/05/18/34.html</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/NIO/" rel="tag"><i class="fa fa-tag"></i> NIO</a></div><div class="post-nav"><div class="post-nav-item"><a href="/post/2019/04/28/33.html" rel="prev" title="Spring中FactoryBean的作用和实现原理"><i class="fa fa-chevron-left"></i> Spring中FactoryBean的作用和实现原理</a></div><div class="post-nav-item"><a href="/post/2019/07/16/40.html" rel="next" title="GitHub上一个很有意思的项目简直让我刷新三观">GitHub上一个很有意思的项目简直让我刷新三观 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div></div><div class="comments" id="valine-comments"></div><script>window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#在开始之前"><span class="nav-number">1.</span> <span class="nav-text">在开始之前</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#关于本教程"><span class="nav-number">1.1.</span> <span class="nav-text">关于本教程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何运行代码"><span class="nav-number">1.2.</span> <span class="nav-text">如何运行代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#输入-输出：概念性描述"><span class="nav-number">2.</span> <span class="nav-text">输入&#x2F;输出：概念性描述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#I-O-简介"><span class="nav-number">2.1.</span> <span class="nav-text">I&#x2F;O 简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么要使用-NIO"><span class="nav-number">2.2.</span> <span class="nav-text">为什么要使用 NIO?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#流与块的比较"><span class="nav-number">2.3.</span> <span class="nav-text">流与块的比较</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#集成的-I-O"><span class="nav-number">2.4.</span> <span class="nav-text">集成的 I&#x2F;O</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#通道和缓冲区"><span class="nav-number">3.</span> <span class="nav-text">通道和缓冲区</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#概述"><span class="nav-number">3.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是缓冲区？"><span class="nav-number">3.2.</span> <span class="nav-text">什么是缓冲区？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缓冲区类型"><span class="nav-number">3.3.</span> <span class="nav-text">缓冲区类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是通道？"><span class="nav-number">3.4.</span> <span class="nav-text">什么是通道？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#通道类型"><span class="nav-number">3.5.</span> <span class="nav-text">通道类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#从理论到实践：NIO-中的读和写"><span class="nav-number">4.</span> <span class="nav-text">从理论到实践：NIO 中的读和写</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#概述-1"><span class="nav-number">4.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#从文件中读取"><span class="nav-number">4.2.</span> <span class="nav-text">从文件中读取</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三个容易的步骤"><span class="nav-number">4.3.</span> <span class="nav-text">三个容易的步骤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#写入文件"><span class="nav-number">4.4.</span> <span class="nav-text">写入文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#读写结合"><span class="nav-number">4.5.</span> <span class="nav-text">读写结合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#运行-CopyFile-例子"><span class="nav-number">4.6.</span> <span class="nav-text">运行 CopyFile 例子</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#检查状态"><span class="nav-number">4.7.</span> <span class="nav-text">检查状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重设缓冲区"><span class="nav-number">4.8.</span> <span class="nav-text">重设缓冲区</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#缓冲区内部细节"><span class="nav-number">5.</span> <span class="nav-text">缓冲区内部细节</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#概述-2"><span class="nav-number">5.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#状态变量"><span class="nav-number">5.2.</span> <span class="nav-text">状态变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Position"><span class="nav-number">5.3.</span> <span class="nav-text">Position</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Limit"><span class="nav-number">5.4.</span> <span class="nav-text">Limit</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Capacity"><span class="nav-number">5.5.</span> <span class="nav-text">Capacity</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#观察变量"><span class="nav-number">5.6.</span> <span class="nav-text">观察变量</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#回想一下-，limit-决不能大于-capacity，此例中这两个值都被设置为-8。我们通过将它们指向数组的尾部之后-如果有第8个槽，则是第8个槽所在的位置-来说明这点。"><span class="nav-number">5.6.0.1.</span> <span class="nav-text">回想一下 ，limit 决不能大于 capacity，此例中这两个值都被设置为 8。我们通过将它们指向数组的尾部之后(如果有第8个槽，则是第8个槽所在的位置)来说明这点。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#position-设置为0。如果我们读一些数据到缓冲区中，那么下一个读取的数据就进入-slot-0-。如果我们从缓冲区写一些数据，从缓冲区读取的下一个字节就来自-slot-0-。-position-设置如下所示："><span class="nav-number">5.6.0.2.</span> <span class="nav-text">position 设置为0。如果我们读一些数据到缓冲区中，那么下一个读取的数据就进入 slot 0 。如果我们从缓冲区写一些数据，从缓冲区读取的下一个字节就来自 slot 0 。 position 设置如下所示：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#由于-capacity-不会改变，所以我们在下面的讨论中可以忽略它。"><span class="nav-number">5.6.0.3.</span> <span class="nav-text">由于 capacity 不会改变，所以我们在下面的讨论中可以忽略它。</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第一次读取"><span class="nav-number">5.7.</span> <span class="nav-text">第一次读取</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#limit-没有改变。"><span class="nav-number">5.7.0.1.</span> <span class="nav-text">limit 没有改变。</span></a></li></ol></li></ol><li class="nav-item nav-level-3"><a class="nav-link" href="#第二次读取"><span class="nav-number">5.8.</span> <span class="nav-text">第二次读取</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#limit-没有改变。-1"><span class="nav-number">5.8.0.1.</span> <span class="nav-text">limit 没有改变。</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#flip"><span class="nav-number">5.9.</span> <span class="nav-text">flip</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#我们现在可以将数据从缓冲区写入通道了。-position-被设置为-0，这意味着我们得到的下一个字节是第一个字节。-limit-已被设置为原来的-position，这意味着它包括以前读到的所有字节，并且一个字节也不多。"><span class="nav-number">5.9.0.1.</span> <span class="nav-text">我们现在可以将数据从缓冲区写入通道了。 position 被设置为 0，这意味着我们得到的下一个字节是第一个字节。 limit 已被设置为原来的 position，这意味着它包括以前读到的所有字节，并且一个字节也不多。</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第一次写入"><span class="nav-number">5.10.</span> <span class="nav-text">第一次写入</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#null"><span class="nav-number">5.10.0.1.</span> <span class="nav-text"></span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第二次写入"><span class="nav-number">5.11.</span> <span class="nav-text">第二次写入</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#-1"><span class="nav-number">5.11.0.1.</span> <span class="nav-text"></span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#clear"><span class="nav-number">5.12.</span> <span class="nav-text">clear</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#缓冲区现在可以接收新的数据了。"><span class="nav-number">5.12.0.1.</span> <span class="nav-text">缓冲区现在可以接收新的数据了。</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#访问方法"><span class="nav-number">5.13.</span> <span class="nav-text">访问方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#get-方法"><span class="nav-number">5.14.</span> <span class="nav-text">get() 方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#put-方法"><span class="nav-number">5.15.</span> <span class="nav-text">put()方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类型化的-get-和-put-方法"><span class="nav-number">5.16.</span> <span class="nav-text">类型化的 get() 和 put() 方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缓冲区的使用：一个内部循环"><span class="nav-number">5.17.</span> <span class="nav-text">缓冲区的使用：一个内部循环</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关于缓冲区的更多内容"><span class="nav-number">6.</span> <span class="nav-text">关于缓冲区的更多内容</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#概述-3"><span class="nav-number">6.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缓冲区分配和包装"><span class="nav-number">6.2.</span> <span class="nav-text">缓冲区分配和包装</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缓冲区分片"><span class="nav-number">6.3.</span> <span class="nav-text">缓冲区分片</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缓冲区份片和数据共享"><span class="nav-number">6.4.</span> <span class="nav-text">缓冲区份片和数据共享</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#只读缓冲区"><span class="nav-number">6.5.</span> <span class="nav-text">只读缓冲区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#直接和间接缓冲区"><span class="nav-number">6.6.</span> <span class="nav-text">直接和间接缓冲区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内存映射文件-I-O"><span class="nav-number">6.7.</span> <span class="nav-text">内存映射文件 I&#x2F;O</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#将文件映射到内存"><span class="nav-number">6.8.</span> <span class="nav-text">将文件映射到内存</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分散和聚集"><span class="nav-number">7.</span> <span class="nav-text">分散和聚集</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#概述-4"><span class="nav-number">7.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分散-聚集-I-O"><span class="nav-number">7.2.</span> <span class="nav-text">分散&#x2F;聚集 I&#x2F;O</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分散-聚集的应用"><span class="nav-number">7.3.</span> <span class="nav-text">分散&#x2F;聚集的应用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#聚集写入"><span class="nav-number">7.4.</span> <span class="nav-text">聚集写入</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件锁定"><span class="nav-number">8.</span> <span class="nav-text">文件锁定</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#概述-5"><span class="nav-number">8.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#锁定文件"><span class="nav-number">8.2.</span> <span class="nav-text">锁定文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#文件锁定和可移植性"><span class="nav-number">8.3.</span> <span class="nav-text">文件锁定和可移植性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#连网和异步-I-O"><span class="nav-number">9.</span> <span class="nav-text">连网和异步 I&#x2F;O</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#概述-6"><span class="nav-number">9.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#异步-I-O"><span class="nav-number">9.2.</span> <span class="nav-text">异步 I&#x2F;O</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Selectors"><span class="nav-number">9.3.</span> <span class="nav-text">Selectors</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#打开一个-ServerSocketChannel"><span class="nav-number">9.4.</span> <span class="nav-text">打开一个 ServerSocketChannel</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#选择键"><span class="nav-number">9.5.</span> <span class="nav-text">选择键</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内部循环"><span class="nav-number">9.6.</span> <span class="nav-text">内部循环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#监听新连接"><span class="nav-number">9.7.</span> <span class="nav-text">监听新连接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#接受新的连接"><span class="nav-number">9.8.</span> <span class="nav-text">接受新的连接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#删除处理过的-SelectionKey"><span class="nav-number">9.9.</span> <span class="nav-text">删除处理过的 SelectionKey</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#传入的-I-O"><span class="nav-number">9.10.</span> <span class="nav-text">传入的 I&#x2F;O</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#回到主循环"><span class="nav-number">9.11.</span> <span class="nav-text">回到主循环</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符集"><span class="nav-number">10.</span> <span class="nav-text">字符集</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#概述-7"><span class="nav-number">10.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#编码-解码"><span class="nav-number">10.2.</span> <span class="nav-text">编码&#x2F;解码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#处理文本的正确方式"><span class="nav-number">10.3.</span> <span class="nav-text">处理文本的正确方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#示例程序"><span class="nav-number">10.4.</span> <span class="nav-text">示例程序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#结束语"><span class="nav-number">11.</span> <span class="nav-text">结束语</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#结束语-1"><span class="nav-number">11.1.</span> <span class="nav-text">结束语</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#参考资料"><span class="nav-number">11.2.</span> <span class="nav-text">参考资料</span></a></li></ol></li></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Guitu" src="/images/avatar.jpg"><p class="site-author-name" itemprop="name">Guitu</p><div class="site-description" itemprop="description">用实力让情怀落地</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">53</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">22</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">67</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://www.yangqq.com/" title="杨青博客 → https://www.yangqq.com/" rel="noopener" target="_blank">杨青博客</a> </span><span class="links-of-author-item"><a href="https://note.guitu18.com/" title="Notepad → https://note.guitu18.com/" rel="noopener" target="_blank">Notepad</a> </span><span class="links-of-author-item"><a href="http://www.jianhuax.com/" title="建华兄 → http://www.jianhuax.com/" rel="noopener" target="_blank">建华兄</a> </span><span class="links-of-author-item"><a href="http://www.python66.com/" title="Python教程 → http://www.python66.com/" rel="noopener" target="_blank">Python教程</a> </span><span class="links-of-author-item"><a href="https://zhantianlun.github.io/" title="湛天伦 → https://zhantianlun.github.io/" rel="noopener" target="_blank">湛天伦</a> </span><span class="links-of-author-item"><a href="https://haowenbo.com/" title="Easy Blog → https://haowenbo.com/" rel="noopener" target="_blank">Easy Blog</a> </span><span class="links-of-author-item"><a href="http://www.ruanyifeng.com/blog/" title="阮一峰 → http://www.ruanyifeng.com/blog/" rel="noopener" target="_blank">阮一峰</a> </span><span class="links-of-author-item"><a href="https://blog.izgq.net" title="ZGQ's Blog → https://blog.izgq.net" rel="noopener" target="_blank">ZGQ's Blog</a> </span><span class="links-of-author-item"><a href="https://www.xukun.wang/" title="徐坤博客 → https://www.xukun.wang/" rel="noopener" target="_blank">徐坤博客</a> </span><span class="links-of-author-item"><a href="https://crossoverjie.top" title="Jie's Blog → https://crossoverjie.top" rel="noopener" target="_blank">Jie's Blog</a></span></div><div class="cc-license motion-element" itemprop="license"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; 2018 – <span itemprop="copyrightYear">2020</span> <span class="with-love"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">Guitu</span> <span class="post-meta-divider">|</span><span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span><script>function createTime(){var n=new Date("2018-03-05 08:58:41");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("timeDate").innerHTML="本站已运行 "+dnum+" 天 ",document.getElementById("times").innerHTML=hnum+" 小时 "+mnum+" 分 "+snum+" 秒"}var now=new Date;setInterval("createTime()",250)</script><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-area-chart"></i> </span><span class="post-meta-item-text">站点总字数：</span> <span title="站点总字数">250k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span class="post-meta-item-text">站点阅读时长 &asymp;</span> <span title="站点阅读时长">3:47</span></div><div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.0</div><span class="post-meta-divider">|</span><div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.6.0</div><span class="post-meta-divider">|</span> <span class="busuanzi-count"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span>访客数 <span class="site-uv" title="总访客量"><span class="busuanzi-value" id="busuanzi_value_site_uv"></span> </span>人次 <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span>访问量 <span class="site-pv" title="总访问量"><span class="busuanzi-value" id="busuanzi_value_site_pv"></span> </span>次</span></div></footer></div><script src="/lib/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script><script src="//cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><script>NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/valine@1/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el: '#valine-comments',
      verify: false,
      notify: false,
      appId: 'Dyx2ULeNQtm8P7lmjhjOEWiW-MdYXbMMI',
      appKey: 'EvXMp4vOR9bPgmH6NP7IRIt7',
      placeholder: "看了那么久，说点什么呗~ 评论时填写邮箱被回复时会收到邮件通知，填写网址后点击昵称可以跳转",
      avatar: 'identicon',
      meta: guest,
      pageSize: '10' || 10,
      visitor: false,
      lang: 'zh-cn' || 'zh-cn',
      path: location.pathname,
      recordIP: true,
      serverURLs: ''
    });
  }, window.Valine);
});</script></body></html><!-- rebuild by neat -->